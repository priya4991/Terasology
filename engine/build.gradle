// Copyright 2021 The Terasology Foundation
// SPDX-License-Identifier: Apache-2.0

// The engine build is the primary Java project and has the primary list of dependencies

import groovy.json.JsonSlurper
import java.time.OffsetDateTime
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter

plugins {
    id("java-library")
    id("org.jetbrains.gradle.plugin.idea-ext")
    id("com.google.protobuf")
    id("terasology-common")
}

// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, etc
apply from: "$rootDir/config/gradle/publish.gradle"

// Declare "extra properties" (variables) for the project - a Gradle thing that makes them special.
ext {
    // Read environment variables, including variables passed by jenkins continuous integration server
    env = System.getenv()

    templatesDir = new File(rootDir, "templates")

    // Stuff for our automatic version file setup
    startDateTimeString = OffsetDateTime.now(ZoneOffset.UTC).format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX"))
    versionBase = new File(templatesDir, "version.txt").text.trim()
    displayVersion = versionBase
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Java Section                                                                                                      //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

sourceSets {
    main {
        proto {
            srcDir "src/main/protobuf"
        }
        java {
            // Adjust output path (changed with the Gradle 6 upgrade, this puts it back)
            destinationDirectory = new File("$buildDir/classes")
        }
        test.java.destinationDirectory = new File("$buildDir/testClasses")
    }
}

// Customizations for the main compilation configuration
configurations {

    // Exclude a couple JWJGL modules that aren't needed during compilation (OS specific stuff in these two perhaps)
    implementation {
        exclude module: "lwjgl-platform"
        exclude module: "jinput-platform"
    }
}

configurations.configureEach {
    resolutionStrategy {
        // always pick reflections fork
        dependencySubstitution {
            substitute(module("org.reflections:reflections:_")).using(module("org.terasology:reflections:_"))
        }
    }
}

// Primary dependencies definition
dependencies {
    // Storage and networking
    api("com.google.guava:guava:_")
    api("com.google.code.gson:gson:_")
    api("net.sf.trove4j:trove4j:_")
    implementation("io.netty:netty-all:_")
    implementation("com.google.protobuf:protobuf-java:_")
    implementation("org.lz4:lz4-java:_")
    implementation("org.apache.httpcomponents:httpclient:_")
    // Javax for protobuf due to @Generated - needed on Java 9 or newer Javas
    // TODO: Can likely replace with protobuf Gradle task and omit the generated source files instead
    implementation("javax.annotation:javax.annotation-api:_")

    //Utilities
    api("org.codehaus.plexus:plexus-utils:_")

    // Java magic
    implementation("net.java.dev.jna:jna-platform:_")
    implementation("org.terasology:reflections:_")
    implementation("com.esotericsoftware:reflectasm:_")

    // Graphics, 3D, UI, etc
    api(platform("org.lwjgl:lwjgl-bom:_"))
    api("org.lwjgl:lwjgl")
    implementation("org.lwjgl:lwjgl-assimp")
    api("org.lwjgl:lwjgl-glfw")
    implementation("org.lwjgl:lwjgl-openal")
    api("org.lwjgl:lwjgl-opengl")
    implementation("org.lwjgl:lwjgl-stb")

    implementation("io.micrometer:micrometer-core:_")
    implementation("io.micrometer:micrometer-registry-jmx:_")
    api("io.projectreactor:reactor-core:_")
    api("io.projectreactor.addons:reactor-extra:_")
    implementation("io.projectreactor.netty:reactor-netty-core:_")

    api("org.joml:joml:_")
    api("org.terasology.joml-ext:joml-geometry:_")

    implementation("org.abego.treelayout:org.abego.treelayout.core:_")
    api("com.miglayout:miglayout-core:_")
    implementation("de.matthiasmann.twl:PNGDecoder:_")

    // Logging
    implementation("org.slf4j:slf4j-api:_") {
        because("a backend-independent Logger")
    }
    implementation("ch.qos.logback:logback-classic:_") {
        because("telemetry implementation uses logback to send to logstash " +
                "and we bundle org.terasology.logback for the regex filter")
    }

    // audio
    implementation("com.projectdarkstar.ext.jorbis:jorbis:_")

    // Small-time 3rd party libs we"ve stored in our Artifactory for access
    implementation("ec.util:MersenneTwister:_")

    // telemetry
    implementation("com.snowplowanalytics:snowplow-java-tracker:_") {
        exclude group: "org.slf4j", module: "slf4j-simple"
    }
    implementation("net.logstash.logback:logstash-logback-encoder:_")

    // Our developed libs
    api("org.terasology.gestalt:gestalt-asset-core:_")
    api("org.terasology.gestalt:gestalt-module:_")
    api("org.terasology.gestalt:gestalt-entity-system:_")
    api("org.terasology.gestalt:gestalt-util:_")
    api("com.github.zafarkhaja:java-semver:_")  // ASAP: Remove after https://github.com/MovingBlocks/gestalt/pull/110

    api("org.terasology:TeraMath:_")
    api("org.terasology:splash-screen:_")
    api("org.terasology.jnlua:JNLua:_")
    api("org.terasology.jnbullet:JNBullet:_")
    api("org.terasology.nui:nui:_")
    api("org.terasology.nui:nui-reflect:_")
    api("org.terasology.nui:nui-gestalt7:_")


    // Wildcard dependency to catch any libs provided with the project (remote repo preferred instead)
    api fileTree(dir: "libs", include: "*.jar")

    // TODO: Consider moving this back to the PC Facade instead of having the engine rely on it?
    implementation("org.terasology.crashreporter:cr-terasology:5.0.0")

    api(project(":subsystems:TypeHandlerLibrary"))
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:_"
    }
    plugins {
    }
}

// Instructions for packaging a jar file for the engine
jar {
    // Unlike the content modules Gradle grabs the assets as they're in a resources directory. Need to avoid dupes tho
    duplicatesStrategy = "EXCLUDE"

    doFirst {
        manifest {
            def manifestClasspath = "$subDirLibs/" + configurations."${sourceSets.main.runtimeClasspathConfigurationName}".collect {
                it.getName()
            }.join(" $subDirLibs/")
            attributes("Class-Path": manifestClasspath, "Implementation-Title": "Terasology", "Implementation-Version": displayVersion + ", engine v" + project.version + " , build number " + env.BUILD_NUMBER)
        }
    }
}

// JMH related tasks

sourceSets {
    jmh {
        java.srcDirs = ["src/jmh/java"]
        resources.srcDirs = ["src/jmh/resources"]
        compileClasspath += sourceSets.main.runtimeClasspath
        java.destinationDirectory = new File("$buildDir/jmhClasses")
    }
}

tasks.register("jmh", JavaExec) {
    dependsOn jmhClasses
    mainClass = "org.openjdk.jmh.Main"
    classpath = sourceSets.jmh.compileClasspath + sourceSets.jmh.runtimeClasspath
}

dependencies {
    jmhAnnotationProcessor("org.openjdk.jmh:jmh-generator-annprocess:1.27")
    jmhImplementation("org.openjdk.jmh:jmh-core:_")
    jmhImplementation("org.openjdk.jmh:jmh-generator-annprocess:_")
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Version file stuff                                                                                                //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// First read the internal version out of the engine"s module.txt
def moduleFile = file("src/main/resources/org/terasology/engine/module.txt")

if (!moduleFile.exists()) {
    println "Failed to find module.txt for engine"
    throw new GradleException("Failed to find module.txt for engine")
}

println "Scanning for version in module.txt for engine"
def slurper = new JsonSlurper()
def moduleConfig = slurper.parseText(moduleFile.text)

// Gradle uses the magic version variable when creating the jar name (unless explicitly set differently)
version = moduleConfig.version

// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor
group = "org.terasology.engine"

println "Version for $project.name loaded as $version for group $group"

// This version info file actually goes inside the built jar and can be used at runtime
def createVersionInfoFile = tasks.register("createVersionInfoFile", WriteProperties) {
    //noinspection GroovyAssignabilityCheck
    properties([
            buildNumber: env.BUILD_NUMBER,
            buildId: env.BUILD_ID,
            buildTag: env.BUILD_TAG,
            buildUrl: env.BUILD_URL,
            jobName: env.JOB_NAME,
            gitCommit: env.GIT_COMMIT,
            displayVersion: displayVersion,
            engineVersion: version
    ].findAll { it.value != null })
    if (env.JOB_NAME != null) {
        // Only set the dateTime property when there is a Jenkins JOB_NAME.
        // It is a value we can always get (on Jenkins or otherwise) but we don't want local builds
        // to invalidate their cache whenever the time changes.
        // TODO: after upgrading to Gradle 6.8, see if we can have it ignore this property specifically:
        //     https://docs.gradle.org/current/userguide/incremental_build.html#sec:property_file_normalization
        property("dateTime", startDateTimeString)
    }

    destinationFile = layout.buildDirectory.dir("createrVersionInfoFile").get().file("versionInfo.properties")
}

tasks.named("processResources", Copy) {
    from(createVersionInfoFile) {
        into("org/terasology/engine/version/")
    }
    from("$rootDir/docs") {
        include("Credits.md")
    }
}

//TODO: Remove this when gestalt can handle ProtectionDomain without classes (Resources)
tasks.register("copyResourcesToClasses", Copy) {
    from processResources
    into sourceSets.main.output.classesDirs.first()

}

tasks.named("compileJava") {
    dependsOn(tasks.named("copyResourcesToClasses"))
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// General IDE customization                                                                                         //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

idea {
    module {
        // Change around the output a bit
        inheritOutputDirs = false
        outputDir = file("build/classes")
        testOutputDir = file("build/testClasses")
        downloadSources = true
    }
}

// Make sure our config file for code analytics get extracted (vulnerability: non-IDE execution of single analytic)
ideaModule.dependsOn rootProject.extractConfig
tasks.eclipse.dependsOn rootProject.extractConfig
check.dependsOn rootProject.extractConfig
